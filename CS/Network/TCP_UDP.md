# TCP/UDP
### 목차
- TCP와 UDP
- TCP의 동작
- UDP의 동작


## [1. TCP와 UDP]
<br/>

> 송신자와 수신자를 연결하는 통신 서비스를 제공하고 IP에 의해 전달되는 패킷의 오류를 검사하며 재전송 요구 제어등을 담당하는 전송 계층의 프로토콜 TCP/UDP
>
> 포트를 사용하여 상위 계층에 데이터 전달 
> 
> IP(단말기 구분) / Port(해당 단말기에서 어떤 프로세스에 전달해야되는지 구분)

## TCP
> 연결 지향적 프로토콜 - 통신을 하기 위해서 두 단말기 사이가 연결된 상태여야 함
>
> 일반적으로 클라이언트 - 서버 관계로 설명됨
>
> 1. 클라이언트가 서버로 연결 요청
> 2. 서버가 연결을 수락 - 두 단말기  가상회선을 고정
> 3. 세그먼트로 분할된 데이터가 정해진 경로를 통해서 순서대로 통신됨
>

#### 특징
- 연결 지향 프로토콜
- 데이터의 경계를 구분하지 않음 (바이트 스트림)
    - 송신측에서 전송한 데이터를 수신측에서 스트림 형태로 받음 (한번 or 여러번에 거쳐서 read)
- 연결의 설정 (3-way-handshaking)과 해제 (4-way-handshaking)
- 전이중(Full-Duplex), 점대점(Point to Point) 서비스
- 일반적으로 IP 프로토콜과 같이 사용되어 IP 계층의 신뢰성 없는 서비스에 대해 신뢰성 제공

#### 장점 
- 안정적이고 신뢰성 있는 데이터 전송
    - 패킷 손실, 중복, 순서바뀜 등이 없도록 보장
- 데이터 흐름 제어 (수신자 버퍼 오버플로우 방지), 혼잡 제어 (패킷 수가 과도하게 증가하는 현상 방지)
- 데이터의 손실 발생 시 재전송 지원 (오류 제어)

#### 단점 
- UDP에 비해 전송속도가 느림
- 데이터로 보내기 전에 반드시 연결이 형성되어야함
- 한 회선당 1 : 1 통신만 가능
- 고정된 통신 경로가 최단선(네트워크 길이)이 아닐경우 상대적으로 UDP보다 데이터 전송속도가 느림

##### 사용
- SMTP, FTP, SSH, TELNET, HTTP

## UDP
> 비연결 지향적 프로토콜 - 통신을 하기 위해서 두 단말기 사이에 미리 연결이 필요하지 않음
>
> 데이터를 주고받을 때 연결 절차를 거치지 않고 송신자가 일방적으로 데이터를 송신하는 방식
>

#### 특징
- 비연결 지향 프로토콜
- 데이터 그램 단위로 데이터를 분할하여 전송
    - 데이터 경계를 구분함
    - 각각의 데이터그램은 서로 다른 경로로 전송될 수 있음
- 통신 과정에서 송신과 수신 신호절차가 존재하지 않음
- 신뢰성 없는 데이터 전송
- 패킷 관리가 필요함

#### 장점 
- 비교적 TCP보다 속도가 빠름
    - 통신을 위한 연결 절차가 존재하지 않음
    - 흐름 · 순서 · 혼잡 제어가 없음
    - Checksum 검사합 외에 특별한 오류 제어가 없음 
- 패킷 오버헤드가 적어 네트워크 부하가 감소
- 여러 다수 지점에 전송 가능
- 헤더가 단순함

#### 단점 
- 전송이 신뢰성이 없음
    - 데이터그램의 올바른 순서, 도착을 보장하지 않음
- UDP를 사용시, 전체 메시지가 올바른 순서로 도착했는지에 대해 확인할 수 있어야함
- 데이터의 손실이 발생해도 재전송하지 않음
- 데이터를 순서대로 재조립하는 과정이 없음

##### 사용
- DNS, RTP(Real Time Protocol - ex.전화), Multicast

## [2. TCP의 동작]

## 2-1. TCP 통신 과정

> TCP 프로토콜의 작동은 크게 세가지 흐름으로 구분하는데 다음과 같다.
>
>1. 연결 생성(Connection establishment)
>2. 자료 전송(Data transfer)
>3. 연결 종료(Connection termination)

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F9910A8345BB0B75F2A0A82)
*출처 : https://www.crocus.co.kr/1362*

<br/>

### 1. 연결 생성 *3-way handshaking*
> 1. 클라이언트는 접속을 요청하는 SYN 패킷을 보낸다. 
>    -  클라이언트는 SYN 패킷을 보냄과 동시에 응답을 기다리기위해 SYN_SENT 상태 전환
><br/><br/>
>2. 서버는 SYN 요청을 받고 클라이언트에게 요청을 수락하는 ACK 패킷과 SYN 패킷 전송 
>    - 서버는 SYN_RCVD(SYN_RECEIVED)상태로 변하여 클라이언트가 ACK 패킷을 보낼 때 까지 대기
><br/><br/>
>3. 클라이언트는 서버에 ACK 패킷을 전송
>    - ESTABLISHED 상태가 되어 데이터 통신이 가능

*즉, ACK 패킷의 Acknowledgement Number는 신뢰적 데이터 전송을 위해 사용*<br/>
*ISN **Initialized Sequence Number** 초기 시퀀스 번호 - SYN 패킷의 Sequence Number는 운영체제의 의해서 랜덤하게 생성*<br/>
*동기화 요청에 대한 답신 - 클라이언트의 시퀀스 넘버에 +1을 해서 ack로 리턴*

### 1. 자료 전송 *3-way handshaking*
> 1. 송신측에서 window의 크기만큼 data 전송
><br/><br/>
> 2. 수신측에서는 데이터를 받게 되면 ACK로 응답
>       - 송신측에서는 ACK를 보낼 필요가 없음

### 3. 연결 종료 *4-way handshaking*
> 1. 서버와 클라이언트가 TCP 연결이 되어있는 상태에서 클라이언트가 접속을 끊기 위해 FIN segmment 전송
>      - 클라이언트는 FIN_WAIT1 상태로 전환<br/><br/>
> 2. 서버는 CLOSE_WAIT 상태로 바꾼 후 ACK segment를 전송한다.
>      - FIN은 클라이언트가 끊을 것이라는 신호를 받은것이고<br/>
>        CLOSE_WAIT를 통해 자신의 통신이 끝날때까지 대기하는 상태로 전환 <br/><br/>
> 3. ACK segment를 받은 클라이언트는 FIN_WAIT2로 변환<br/><br/>
> 4. 종료 프로세스를 모두 수행한 서버는 FIN segment를 전송하고 LAST_ACK 상태로 전환<br/><br/>
> 5. 서버도 연결을 닫았다는 신호를 클라이언트가 수신하면 <br/>ACK segment를 보낸 후 TIME_WAIT 상태로 전환
> <br/><br/>
>
> 이 후 모든것이 끝나면 CLOSED 상태로 변환
>
> LAST_ACK : 연결은 종료되고 승인을 기다리는 상태

### 비정상 종료 상황
> 서버 or 클라이언트에서 응답을 받지 못해 FIN_WAIT1, FIN_WAIT2, CLOSE_WAIT에서 무한정 대기
>
> CLOSE_WAIT 상태 : FIN segment를 받은 수신 측에서 close 하지 않은 상태 
>   - 적절한 close 호출 필요
>
> FIN_WAIT1 상태 : 상대방측에 커넥션 종료 요청을 했는데, ACK를 받지 못한 상태로 대기
>   - 시간(Time out)이 지나면 종료됨
>
> FIN_WAIT2 상태 : 서버에서 종료를 완료했다는 FIN 을 받지 못하고 기다리고 있는 상태
>   - 시간(Time out)이 지나면 종료됨

---

> Q. 3-way handshaking과 4-way handshaking 이 필요한 이유가 뭔가요?

> Q. 4-way handshaking에서 클라이언트에서 TIME_WAIT가 필요한 이유가 뭔가요?

> Q. HTTP 는 비연결성 특징을 가지는데 어떻게 TCP 기반인가요?

    - HTTP는 클라이언트가 서버와 계속해서 연결을 유지하지 않음 
    - 연결 > 응답 > 종료가 한번에 이루어짐


## 2-2. TCP 통신 특징

> TCP 통신은 흐름제어, 오류제어, 혼잡제어의 기능을 가진다.

### 흐름 제어
### 오류 제어
### 혼잡 제어
