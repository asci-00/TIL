# 메모리 관리
## 목차
- 메모리 관리 목적
- 단편화
- 메모리 할당
- 가상 메모리
- 페이징 Paging
- 세그멘테이션 Segmentation


## [1. 메모리 관리 목적]
<br/>

### 메모리 관리란?

> 실행하려는 프로세스는 메모리에 적재되어 있어야 함
>
> 여러개의 프로세스를 동시에 수행하는 환경에서 한정된 메모리 자원을 효율적으로 관리하기 위한 전략
>
> 메모리 관리를 위해 메모리 관리 장치 MMU *Memory Management Unit*와 OS의 메모리 관리정책이  존재

### 정책

#### 적재 정책 *Fetch Policy*
> 디스크에서 메모리로 프로세스를 언제 가져와야 할지 결정
>   - 요구 적재 *Demand Fetch* - 필요할 때 프로세스 (or 페이지 / 세그먼트) 적재
>       - overhead 최소화 / 대기시간 증가
>   - 예상 적재 *Anticipatory Fetch* - 시스템의 요청을 미리 예측하여 프로세스 적재
>       - overhead 초래 / 효율성 향상

#### 배치 정책 *Placement Policy*
> 디스크에서 메모리로 가져온 프로세스를 어느 위치에 배치할것인지 결정
>   - 최초 적합 *First Fit* - 적재 가능한 공간 중 첫번째 공간에 배치
>   - 최적 적합 *Best Fit* - 적재 가능한 공간 중 프로세스 (or 페이지 / 세그먼트) 크기에 가장 적합한 공간에 배치
>   - 최악 적합 *Worst Fit* - 적재 가능한 공간 중 가장 큰 공간에 배치
> 최적 적합이 항상 효율적이지는 않음

#### 교체 정책 *Replacement Policy*
> 메모리가 충분하지 않을 때, 현재 적재된 프로세스 중 제거할 프로세스를 결정
> LRU / LFU / FIFO 등의 교체 알고리즘이 존재


## [2. 단편화]
<br/>

> 프로세스 (or 페이지 / 세그먼트)를 메모리에 할당 해제를 반복하다보면
>
> 메모리에 충분한 공간이 존재함에도 불구하고 프로세스를 적재시킬 수 없는 상황이 발생
>
> 이를 단편화라고 하며 외부 단편화, 내부 단편화가 존재

![](https://kouzie.github.io/assets/OS/OS_10_8.png)

*출처 : https://jaeyeon93.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EA%B8%B0%EC%B4%88(12)%EB%A9%94%EB%AA%A8%EB%A6%AC%ED%95%A0%EB%8B%B9/*

### 내부 단편화

> 메모리를 고정 크기로 분할할 때, 발생됨
1. 고정된 크기에 프로세스(or 부분) 할당
2. 프로세스가 고정된 크기보다 작을 경우, 남는 메모리 발생
3. 2번의 과정 반복으로 잔여 메모리가 충분한데도 프로세스가 적재 못하는 상황 발생

### 외부 단편화

> 메모리를 가변 크기로 분할할 때 발생됨

1. 위와같이 메모리 할당 & 해제가 반복해서 발생 시, 흩어진 공백 *scattered holes*이 발생
2. 흩어진 잔여 공간을 합치면 충분히 프로세스를 적재할 수 있음에도 불구하고 적재가 불가능한 상태

#### 해결
1. 메모리 할당 정책으로 연속 메모리 할당 방식 사용 (최초, 최적, 최악 적합)
   1. 효율이 좋으나, 완전히 해결되지 않아 외부 단편화로 인해 1/3정도의 낭비가 발생
2. 압축 *Compaction* 방식 사용
   1. 메모리를 욺겨 흩어진 공간을 한곳으로 모으는 방식
   2. 바인딩(메모리 계산)에 의해 비용 부담이 큼

## [3. 메모리 할당]
> 프로세스에게 메모리를 할당할 때, 스와핑, 연속할당 과 불연속 할당으로 크게 세 가지 기법이 존재

### 스와핑 **Swapping**
> 부족한 메모리 공간을 좀 더 효율적으로 관리하려는 메모리 관리 기법.
>
> CPU에서 시행되지 않는 프로세스 즉 ready상태이거나 waiting상태에 있는 프로세스들 중 일부를
>
> 메모리 안에 보관하지 않고 하드디스크 같은 저장장치에 보관 Swap out

> #### Swap-in
> - 준비 ready 혹은 대기 waiting 상태인 프로세스를 보조기억장치에 저장 (Ready Queue로 들어가지 않음)
>   - 프로세스가 가지는 상태(리소스, 데이터, 힙, 스택 등)을 그대로 저장
> #### Swap-out
> - CPU 스케줄러에 의해 running 상태로 전환되면 보조기억장치에 저장된 데이터를 그대로 메모리에 적재
> - 메모리상에 적재되기 위해 바인딩 작업 필요

#### 장점
- 보조기억장치를 활용하여 큰 메모리를 운용하는 효율적인 메모리 관리 기법
#### 단점
- 문맥교환이 매우 비효율적
  - 보조기억장치의 속도와 메모리의 속도차이가 매우 큼

### 연속 메모리 할당
> 메모리에 프로세스를 적재할 때, 연속적인 공간에 적재시키는 것 (프로세스 자체를 분할하지 않음)
>
> 고정 분할 방법과 가변 분할 방법이 존재
>
> 비어있는 공간의 크기가 모두 같기 때문에, 비어있는 아무 공간에 프로세스 적재
>
> 단편화 문제가 심각하여 현재 사용되지 않으며, 효율이 좋은 불연속 메모리 할당이 개발됨
>
> MMU는 각 프로세스의 시작 위치만을 relocation register에 저장

#### 1. 고정 분할

- 메모리를 고정된 크기로 나누어 프로세스 할당
- **내부 단편화** 발생

#### 2. 가변 분할

- 고정된 경계값을 없애고 각 프로세스가 필요한 만큼 메모리를 할당하는 방법
- 비어있는 공간의 크기가 다르므로 프로세스를 할당할 때, 최초, 최적, 최악 할당기법을 사용
- 프로세스가 할당 해제를 반복하다보면 **외부 단편화** 발생

### 불연속 메모리 할당
> 프로세스가 연속적으로 할당되지 않고, 일정한 크기로 분할하여 메모리에 불연속적으로 적재
>